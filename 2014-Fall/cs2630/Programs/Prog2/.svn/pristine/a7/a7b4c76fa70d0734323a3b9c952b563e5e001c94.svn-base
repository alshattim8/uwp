#include "LList.h"
#include "LeakWatcher.h"

LList::~LList()
{
   if (list != NULL)
   {
      Node * p = list->next;
      while (p != NULL)
      {
         delete list;
         list = p;
         p = p->next;
      }
      delete list;
   }
}

bool LList::IsEmpty() const
{
   return list == NULL;
}

bool LList::Insert(InfoType *x_ptr)
{
   if (list == NULL)
   {
      list = new Node(x_ptr, list);
      return true;
   }
   else if (*x_ptr < *list->infoPtr)
   {
      list = new Node(x_ptr, list);
      return true;
   }
   else if (*x_ptr == *list->infoPtr)
   {
      return false;
   }
   else
   {
      Node * p = list;
      while (p->next != NULL && *p->next->infoPtr < *x_ptr  )
      {
         p = p->next;
         if (*x_ptr == *p->infoPtr)
         {
            return false;
         }
      }
      if (p->next != NULL && *x_ptr == *p->next->infoPtr)
      {
         return false;
      }
      else
      {
         p->next = new Node(x_ptr, p->next);
         return true;
      }
   }
}

bool LList::Delete(const InfoType & x)
{
   if (list != NULL)
   {
      Node * p = list;
      if (x == *p->infoPtr)
      {
         list = list->next;
         delete p;
         return true;
      }
      else
      {
         p = p->next;
         if (p->next == NULL)
         {
            return false;
         }

         Node * q = list;
         while (p->next != NULL)
         {
            if (x == *p->infoPtr)
            {
               q->next = p->next;
               p->next = NULL;
               delete p;
               return true;
            }
            p = p->next;
            q = q->next;
         }
         if (*p->infoPtr == x)
         {
            q->next = p->next;
            p->next = NULL;
            delete p;
            return true;
         }
      }
   }
   return false;
}

void LList::Display(ostream & out_stream) const
{
   Node * p = list;
   while (p != NULL)
   {
      out_stream << *p->infoPtr << endl;
      p = p->next;
   }
}

#ifdef TESTING_LLIST

void main()
{

}

#endif